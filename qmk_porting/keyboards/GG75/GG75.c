/*
Copyright 2022 Huckies <https://github.com/Huckies>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include QMK_KEYBOARD_H
#include "quantum/color.h"
#ifdef RGB_MATRIX_ENABLE

/* clang-format off */
led_config_t g_led_config = {
	{
		{0,   1,   2,   3,     4,     5,      6,   7,     8,     9,      10,  11,  12,  13,  NO_LED,   NO_LED}, 
		{14,  15,  16,  17,    18,    19,     20,  21,    22,    23,     24,  25,  26,  27,  NO_LED,   NO_LED},     
		{28,  29,  30,  31,    32,    33,     34,  35,    36,    37,     38,  39,  40,  41,  42,  NO_LED}, 
		{43,  44,  45,  46,    47,    48,     49,  50,    51,    52,     53,  54,  55,  56,  57,  58},   
        {60,  61,  62,  63,    64,    65,     66,  67,    68,    69,     70,  71,  72,  73,  74,  75}, 
		{76,  77,  78,  NO_LED,NO_LED,NO_LED, 79,  NO_LED,NO_LED,NO_LED, 77,  78,  79,  80,  81,  82,  83,84,85,86,87,88,89,90,91,92,93,94,95}, 


	}, {
		{0,0},  {15,0}, {30,0}, {45,0}, {60,0}, {75,0}, {90,0},  {105,0}, {119,0}, {134,0}, {149,0}, {164,0}, {179,0}, {194,0},              
        {0,13}, {15,13},{30,13},{45,13},{60,13},{75,13},{90,13}, {105,13},{119,13},{134,13},{149,13},{164,13},{179,13},{194,13},              
        {0,26}, {15,26},{30,26},{45,26},{60,26},{75,26},{90,26}, {105,26},{119,26},{134,26},{149,26},{164,26},{179,26},{194,26},      
        {15,38},{30,38},{45,38},{60,38},{75,38},{90,38},{105,38},{119,38},{134,38},{149,38},{164,38},{179,38},{194,38},{209,38},{224,38},{209,26},  
        {15,51},{30,51},{45,51},{60,51},{75,51},{90,51},{105,51},{119,51},{134,51},{149,51},{164,51},{179,51},{194,51},{209,51},{224,51},
        {0,64}, {15,64},{30,64},                        {90,64},                            {149,64},{164,64},{179,64},{194,64},{209,64},{224,64},
        {0,64},{0,64},{0,64},{0,64},{0,64},{0,64},{0,64},{0,64},{0,64},{0,64},{0,64},{0,64},{0,64},

	}, {
		4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
		4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
		4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
		4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
		4, 4, 4,          4,          4, 4, 4, 4, 4, 4, 
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
	}
};
/* clang-format on */
uint rgb_test = 0;
uint32_t rgb_test_timeout_timer = 0;

void rgbtest()
{
    rgb_test = 1;
    rgb_test_timeout_timer = timer_read();
}

uint8_t startup = 0;
uint32_t rgb_startup_timeout_timer = 0;
uint8_t startup_h = 0;
HSV startupHSV;
uint8 startup_b = 2;
void rgb_matrix_indicators_advanced_user(uint8_t led_min, uint8_t led_max)
{
     startupHSV.s = rgblight_get_sat();
     startupHSV.v = rgblight_get_val();
    cRGB startup_c;
    //startup_c = hsv_to_rgb(startup_h, startup_s, startup_v);
    if (startup == 1)
    {
        if(timer_elapsed32(rgb_startup_timeout_timer) < 200)
        {  
            rgb_matrix_set_color_all(0,0,0); //turn off all leds  
        }
        else if(timer_elapsed32(rgb_startup_timeout_timer) < 300 )
        {  
            setPinOutput(A3) ;
            writePinHigh(A3) ;
            rgb_matrix_set_color_all(0,0,0); //turn off all leds  
        }
        else if(timer_elapsed32(rgb_startup_timeout_timer) < 1300  )
        {  
            if(timer_elapsed32(rgb_startup_timeout_timer)  % 5 == 0)
            {
                startupHSV.h += 3;
            }
            if(timer_elapsed32(rgb_startup_timeout_timer)  % 100 == 0)
            {
                startup_b += 1;
            }
            startup_c = hsv_to_rgb(startupHSV);
            
            rgb_matrix_set_color_all(startup_c.r/startup_b,startup_c.g/startup_b,startup_c.b/startup_b); //turn off all leds  
    
        }
        else if(timer_elapsed32(rgb_startup_timeout_timer) < 2300  )
        {  
            if(timer_elapsed32(rgb_startup_timeout_timer)  % 5 == 0)
            {
                startupHSV.h += 3;
            }
            if(timer_elapsed32(rgb_startup_timeout_timer)  % 100 == 0)
            {
                startup_b -= 1;
            }
            startup_c = hsv_to_rgb(startupHSV);
            
            rgb_matrix_set_color_all(startup_c.r/startup_b,startup_c.g/startup_b,startup_c.b/startup_b); //turn off all leds  
    
        }
        else if(timer_elapsed32(rgb_startup_timeout_timer) < 2400  )
        {  
           setPinInputLow(A3) ;
            writePinLow(A3) ;
        }
        else
        {
            startup = 0;
            setPinOutput(A3) ;
            writePinHigh(A3) ;
            rgb_matrix_set_color_all(0,0,0); //turn off all leds  
        }

    }
    else
    {
        if (rgb_test == 0)
        {
            if (host_keyboard_led_state().caps_lock) {
                if (g_led_config.flags[0] & LED_FLAG_KEYLIGHT) {
                    rgb_matrix_set_color(43, 5,0,0);
                    rgb_matrix_set_color(44,  5,0,0);
                }
            }
            if (host_keyboard_led_state().scroll_lock) {
                if (g_led_config.flags[0] & LED_FLAG_KEYLIGHT) {
                    rgb_matrix_set_color(13,  5,0,0);
                }
            }           

        }
        else
        {
            if(timer_elapsed32(rgb_test_timeout_timer) < 1000)
            {
                rgb_matrix_set_color_all(5,0,0); //turn off all leds  
            }
            else if (timer_elapsed32(rgb_test_timeout_timer) < 2000)
            {
                rgb_matrix_set_color_all(0,5,0); //turn off all leds  
            }
            else if (timer_elapsed32(rgb_test_timeout_timer) < 3000)
            {
                rgb_matrix_set_color_all(0,0,5); //turn off all leds  
            }
            else if (timer_elapsed32(rgb_test_timeout_timer) < 4000)
            {
                rgb_test = 0;
            }

        }
    }
}

#endif

#ifdef OLED_ENABLE
#define BONGO_TIMEOUT 100 // the amount of time it takes to return to idle
uint32_t bongo_timeout_timer = 0;

#define BONGO_FRAMES 20
#define ANIM_SIZE 636 // number of bytes in array, minimize for adequate firmware size, max is 1024
#define IDLE_FRAMES 1
#define IDLE_TIMEOUT 800 // the amount of time it takes to return to idle

#define TAP_FRAMES 2
#define KEYS_SIZE MATRIX_ROWS*MATRIX_COLS // the number of keys stored in the array that tracks keypresses; how many keys are on the board?

enum anim_states
{
    Idle,
    Prep,
    Tap
};
uint8_t anim_state = Idle;
uint32_t idle_timeout_timer = 0;

uint8_t current_tap_frame = 0;

struct pair_int_int
{
    uint8_t first;
    uint8_t second;
};
struct pair_int_int pressed_keys[KEYS_SIZE];
struct pair_int_int pressed_keys_prev[KEYS_SIZE];
uint8_t pressed_keys_index = 0;

bool key_down = 0;
static const char PROGMEM idle_minimal[IDLE_FRAMES][ANIM_SIZE] =
{
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x80, 0x80, 0x40, 0x40, 0x40, 0x20, 0x20, 0x20, 0x20, 0x20, 0x18, 0x04, 0x02,
        0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x20, 0x40, 0x40, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x40, 0x40, 0x40, 0x40, 0x20, 0x20, 0x20, 0x20,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xc1, 0x01, 0x01, 0x02, 0x02, 0x04, 0x04, 0x04,
        0x04, 0x02, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x40,
        0x80, 0x80, 0x40, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x04, 0x08,
        0x08, 0x10, 0x20, 0x40, 0x80, 0x80, 0x80, 0x80, 0x40, 0x40, 0x40, 0x40, 0x20, 0x20, 0x20, 0x20,
        0x10, 0x10, 0x10, 0x10, 0x08, 0x08, 0x08, 0x08, 0x04, 0x04, 0x04, 0x04, 0x02, 0x02, 0x02, 0x02,
        0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x18, 0x06, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x83, 0x83, 0x40, 0x40, 0x40, 0x40, 0x20, 0x21, 0x21, 0x20,
        0x10, 0x10, 0x10, 0x10, 0x08, 0x08, 0x08, 0x08, 0x04, 0x04, 0x04, 0x04, 0x04, 0x08, 0x30, 0x40,
        0x80, 0x80, 0x00, 0x00, 0x01, 0x86, 0x98, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x40, 0x40, 0x40, 0x40, 0x20, 0x20, 0x20, 0x20,
        0x10, 0x10, 0x10, 0x10, 0x08, 0x0f, 0x08, 0x08, 0x04, 0x04, 0x04, 0x04, 0x02, 0x04, 0x08, 0x10,
        0x10, 0x20, 0x20, 0x40, 0x40, 0x41, 0x42, 0x24, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
static const char PROGMEM prep_minimal[][ANIM_SIZE] =
{
    {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x40, 0x40, 0x20, 0x20, 0x10, 0x08, 0x04,
        0x02, 0x04, 0x08, 0x10, 0x10, 0x20, 0x20, 0x40, 0x40, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x40, 0x40, 0x40, 0x40, 0x20, 0x20, 0x20, 0x20,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xc1, 0x01, 0x01, 0x02, 0x02, 0x04, 0x84, 0x44,
        0x44, 0x42, 0x82, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x40,
        0x80, 0x80, 0x40, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x64, 0x18, 0x04,
        0x12, 0xc2, 0xca, 0x24, 0x88, 0xf0, 0x80, 0x80, 0x40, 0x40, 0x40, 0x40, 0x20, 0x20, 0x20, 0x20,
        0x10, 0x10, 0x10, 0x10, 0x08, 0x08, 0x08, 0x08, 0x04, 0x04, 0x04, 0x04, 0x02, 0x02, 0x02, 0x02,
        0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x18, 0x06, 0x01, 0x00, 0x00, 0x0c, 0x03, 0x00, 0x02,
        0x18, 0x19, 0x00, 0x05, 0xfe, 0x80, 0x83, 0x83, 0x40, 0x40, 0x40, 0x40, 0x20, 0x21, 0x21, 0x20,
        0x10, 0x10, 0x10, 0x10, 0x08, 0x08, 0x08, 0x08, 0x04, 0x04, 0x04, 0x04, 0x02, 0x02, 0x02, 0x02,
        0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x40, 0x40, 0x40, 0x40, 0x20, 0x20, 0x20, 0x20,
        0x10, 0x10, 0x10, 0x10, 0x08, 0x0f, 0x08, 0x08, 0x04, 0x04, 0x04, 0x04, 0x02, 0x02, 0x02, 0x02,
        0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    }
};
static const char PROGMEM tap_minimal[TAP_FRAMES][ANIM_SIZE] =
{
    {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x40, 0x40, 0x20, 0x20, 0x10, 0x08, 0x04,
        0x02, 0x04, 0x08, 0x10, 0x10, 0x20, 0x20, 0x40, 0x40, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x40, 0x40, 0x40, 0x40, 0x20, 0x20, 0x20, 0x20,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xc1, 0x01, 0x01, 0x02, 0x02, 0x04, 0x04, 0x04,
        0x04, 0x02, 0x02, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x40,
        0x80, 0x80, 0x40, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x64, 0x18, 0x04,
        0x12, 0xc2, 0xca, 0x24, 0x88, 0xf0, 0x80, 0x80, 0x40, 0x40, 0x40, 0x40, 0x20, 0x20, 0x20, 0x20,
        0x10, 0x10, 0x10, 0x10, 0x08, 0x08, 0x08, 0x08, 0x04, 0x04, 0x04, 0x04, 0x02, 0x02, 0x02, 0x02,
        0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x18, 0x06, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x83, 0x83, 0x40, 0x40, 0x40, 0x40, 0x20, 0x21, 0x21, 0x20,
        0x10, 0x10, 0x10, 0x10, 0x08, 0x08, 0x08, 0x08, 0x04, 0x04, 0x04, 0x04, 0x02, 0x02, 0x02, 0x02,
        0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x40, 0x40, 0x40, 0x40, 0x20, 0x20, 0x20, 0x20,
        0x10, 0x10, 0x10, 0x10, 0x08, 0x0f, 0x08, 0x08, 0x04, 0x04, 0x04, 0x04, 0x02, 0x04, 0x08, 0x10,
        0x10, 0x20, 0x20, 0x40, 0x40, 0x41, 0x42, 0x24, 0x98, 0xc0, 0x88, 0x88, 0x8c, 0x9c, 0x1c, 0x1e,
        0x0e, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    },
    {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x40, 0x40, 0x20, 0x20, 0x10, 0x08, 0x04,
        0x02, 0x04, 0x08, 0x10, 0x10, 0x20, 0x20, 0x40, 0x40, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x40, 0x40, 0x40, 0x40, 0x20, 0x20, 0x20, 0x20,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xc1, 0x01, 0x01, 0x02, 0x02, 0x04, 0x84, 0x44,
        0x44, 0x42, 0x82, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x40,
        0x80, 0x80, 0x40, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x04, 0x08,
        0x08, 0x10, 0x20, 0x40, 0x80, 0x80, 0x80, 0x80, 0x40, 0x40, 0x40, 0x40, 0x20, 0x20, 0x20, 0x20,
        0x10, 0x10, 0x10, 0x10, 0x08, 0x08, 0x08, 0x08, 0x04, 0x04, 0x04, 0x04, 0x02, 0x02, 0x02, 0x02,
        0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x18, 0x06, 0x01, 0x00, 0x00, 0x0c, 0x03, 0x00, 0x02,
        0x18, 0x19, 0x00, 0x05, 0xfe, 0x80, 0x83, 0x83, 0x40, 0x40, 0x40, 0x40, 0x20, 0x21, 0x21, 0x20,
        0x10, 0x10, 0x10, 0x10, 0x08, 0x08, 0x08, 0x08, 0x04, 0x04, 0x04, 0x04, 0x04, 0x08, 0x30, 0x40,
        0x80, 0x80, 0x00, 0x00, 0x01, 0x86, 0x98, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x40, 0x40, 0x40, 0x40, 0x20, 0x20, 0x20, 0x20,
        0x10, 0x10, 0x10, 0x10, 0x08, 0x0f, 0x08, 0x08, 0x04, 0x04, 0x04, 0x04, 0x02, 0x02, 0x02, 0x02,
        0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x0f, 0x0f, 0x07, 0x03, 0x03, 0x61, 0xf0, 0xf8,
        0xfc, 0x60, 0x01, 0x01, 0x01, 0x3c, 0x78, 0xf8, 0xf0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    }
};


bool detect_key_down(void)
{
    // store the previous cycle's cache
    for (uint8_t i = 0; i < KEYS_SIZE; ++i)
    {
        pressed_keys_prev[i].first = pressed_keys[i].first;
        pressed_keys_prev[i].second = pressed_keys[i].second;
    }

    // fill cache with currently pressed keys
    pressed_keys_index = 0;
    for (uint8_t x = 0; x < MATRIX_ROWS; x++)
    {
        for (uint8_t y = 0; y < MATRIX_COLS; y++)
        {
            // is this key is currently down?
            if (((matrix_get_row(x) & (1 << y)) > 0))
            {
                pressed_keys[pressed_keys_index].first = x+1; // adding 1 to the row/col so that we can use 0 as a null-check
                pressed_keys[pressed_keys_index].second = y+1;
            }
            else
            {
                pressed_keys[pressed_keys_index].first = 0;
                pressed_keys[pressed_keys_index].second = 0;
            }
            pressed_keys_index++;
        }
    }

    // check for a new key down compared to last cycle
    for (uint8_t i = 0; i < KEYS_SIZE;i++)
    {
        if (pressed_keys[i].first && pressed_keys[i].second && !pressed_keys_prev[i].first && !pressed_keys_prev[i].second)
        {
            return true;
        }
    }
    return false;
}
void eval_anim_state(void)
{
    key_down = detect_key_down();

    switch (anim_state)
    {
        case Idle:
            if (key_down) // Idle to Tap
            {
                anim_state = Tap;
            }
            break;

        case Prep:
            if (key_down) // Prep to Tap
            {
                anim_state = Tap;
            }
            else if (timer_elapsed32(idle_timeout_timer) >= IDLE_TIMEOUT) // Prep to Idle
            {
                anim_state = Idle;
            }
            break;
        case Tap:
            if (!key_down) // Tap to Prep
            {

                anim_state = Prep;
                idle_timeout_timer = timer_read32();

                
            }
            break;

        default:
            break;
    }
}

static void draw_bongo()
{
    eval_anim_state();

    oled_set_cursor(0, 0);

    switch (anim_state)
    {
        case Idle:
            oled_set_cursor(0, 4);
            oled_write_raw_P(idle_minimal[0], ANIM_SIZE);

            break;

        case Prep:
            oled_set_cursor(0, 4);
            oled_write_raw_P(prep_minimal[0], ANIM_SIZE);

            break;

        case Tap:
            oled_set_cursor(0, 4);
            oled_write_raw_P(tap_minimal[current_tap_frame], ANIM_SIZE);
            current_tap_frame = (current_tap_frame + 1) % TAP_FRAMES;
            
            break;

        default:
            break;
    }

}
uint oled_mode = 0;
uint oled_cleaned = 0;


char OLED_S[16];
volatile UINT16 PC_CPU_temp = 0;
volatile UINT16 PC_CPU_rate = 0;
volatile UINT16 PC_GPU_temp = 0;
volatile UINT16 PC_GPU_rate = 0;

void draw_hardwave()
{
    sprintf(OLED_S, "CPU:%03d%%  %03dC", PC_CPU_rate,PC_CPU_temp); 
    oled_set_cursor(0, 4);



    oled_write_ln_P(OLED_S, false);

    sprintf(OLED_S, "GPU:%03d%%  %03dC", PC_GPU_rate,PC_GPU_temp); 
    oled_set_cursor(0, 6);
    oled_write_ln_P(OLED_S, false);
    
}

bool oled_task_user(void) {
    if(oled_cleaned){
        oled_clear();
    }
        // Host Keyboard LED Status
    led_t led_state = host_keyboard_led_state();
    oled_write_P(led_state.caps_lock ? PSTR("CAPLK ") : PSTR("_____ "), false);
    oled_write_P(led_state.num_lock ? PSTR("NUMLK ") : PSTR("_____ "), false);
    oled_write_P(led_state.scroll_lock ? PSTR("SCRLK") : PSTR("_____"), false);
    // Host Keyboard Layer Status
    oled_set_cursor(0, 2);
    oled_write_P(PSTR("Layer: "), false);

    switch (get_highest_layer(layer_state)) {
        case 0:
            oled_write_P(PSTR("0\n"), false);
            break;
        case 1:
            oled_write_P(PSTR("1\n"), false);
            break;
        case 2:
            oled_write_P(PSTR("2\n"), false);
            break;
        case 3:
            oled_write_P(PSTR("3\n"), false);
            break;
        case 4:
            oled_write_P(PSTR("4\n"), false);
            break;
        case 5:
            oled_write_P(PSTR("5\n"), false);
            break;
        default:
            oled_write_ln_P(PSTR("Undefined"), false);
    }

    if (oled_mode  == 0)
    {
        draw_bongo();
    }
    else
    {
        draw_hardwave();
    }
   
    return false;
}
#endif
#define OLED_MODE 24460
bool process_record_user(uint16_t keycode, keyrecord_t * record) {
    switch (keycode) {
        case RGB_M_T:
            if (record->event.pressed) {
                rgbtest();
            }
            return false;
        case OLED_MODE:
            if (record->event.pressed) {
                oled_cleaned = 1;
                if(oled_mode == 0)
                    oled_mode =1;
                else
                    oled_mode =0;
            }
            return false;
        default:
            return true;
    }
}
void raw_hid_receive_kb(uint8_t *data, uint8_t length) {
    uint8_t *command_id = &(data[0]);
    uint8_t *command_data = &(data[1]);
    switch ( *command_id )
    {
        case 0x03:
        {
            if(data[1] == 0xfb)
            {
                PC_CPU_temp = data[2];
                PC_CPU_rate = data[3];
                PC_GPU_temp = data[4];
                PC_GPU_rate = data[5];
            }
           
            break;
        }
        default:
        {
            // Unhandled message.
            *command_id = id_unhandled;
            *command_data = *command_data; // force use of variable
            break;
        }
    }
    // DO NOT call raw_hid_send(data,length) here, let caller do this
}

bool dip_switch_update_user(uint8_t index, bool active) { 
    switch (index) {
        case 0:
            break;
        case 1:
            if (active) {
                layer_on(4);
            } else {
                
                layer_off(4);
            }
            break;
        case 2:
            if (active) {
                layer_on(2);
            } else {
                
                layer_off(2);
            }
            break;

    }
    return true;
}



void keyboard_pre_init_user(void) 
{

}

void keyboard_post_init_user()
{
#ifdef PLF_DEBUG
    print("Set log output for QMK.\n");
#endif
   setPinInputLow(A3) ;
   writePinLow(A3) ;
   
   rgb_matrix_set_color_all(0,0,0); //turn off all leds  
   //DelayMs(200);
   startup = 1;
       rgb_startup_timeout_timer = timer_read();
       startupHSV.h = 0;
}
